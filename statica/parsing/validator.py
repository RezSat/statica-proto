"""
AST Validator for Statica DSL.

This module provides semantic validation for the Abstract Syntax Tree (AST)
generated by the parser. It checks for logical errors such as undefined variables,
invalid command parameters, and type mismatches before execution.

The validator uses the execution context to verify references to datasets or variables.
"""
import os
from typing import List, Dict, Any
from lark import Visitor, Tree
from ..core.context import Context
from ..core.exceptions import ValidationError


class ASTValidator(Visitor):
    """Validator for Statica AST.

    Performs semantic checks on the parsed AST to ensure validity.
    Requires a Context instance to check existing variables and datasets.
    """

    def __init__(self, context: Context) -> None:
        """Initialize the validator with execution context.

        Args:
            context: The runtime context for checking variable existence.
        """
        self.context = context

    def validate(self, ast: List[Dict[str, Any]]) -> None:
        """Validate the entire AST.

        Iterates through each command in the AST and performs semantic checks.
        Raises ValidationError on issues.

        Args:
            ast: List of command dictionaries from the parser.

        Raises:
            ValidationError: If semantic issues are found.
        """
        for stmt in ast:
            if isinstance(stmt, dict):
                cmd = stmt.get('cmd')
            elif isinstance(stmt, Tree):
                cmd = stmt.children[0].get('cmd')
            else:
                raise ValueError("Unrecognized statement type received")
            method_name = f'_validate_{cmd}'
            if cmd:
                method = getattr(self, method_name)
                method(stmt)

    def _validate_assign(self, stmt: Dict[str, Any]) -> None:
        var_name = stmt.children[0].get('name')
        if not var_name:
            print(ValidationError("Variable name is missing"))
        next_smt = stmt.children[0].get('expr')
        if not next_smt:
            print(ValidationError("Expression to assign is missing"))
        if isinstance(next_smt, dict) and "cmd" in next_smt:
            self.validate([next_smt]) # nested validation
        

    def _validate_load(self, stmt: Dict[str, Any]) -> None:
        if isinstance(stmt, dict):
            if isinstance(stmt.get("file"), str) or stmt["file"]:
                # move this into a single utility function
                # used in the interpreter and validator
                base_dir = self.context.base_dir
                full_path = os.path.join(base_dir, stmt['file'])
                try:
                    open(full_path, 'r')
                except Exception as e:
                    raise FileNotFoundError("Coudn't locate the file:", full_path)
            else:
                raise ValidationError("Load command requires a non-empty string filename.")
            if not isinstance(stmt.get("header"), bool):
                raise ValidationError("Header option must be a boolean. (use `with header` or don't)")
        else:
            raise NotImplementedError("Load statment recieved non dict object - probably a lark Tree")

    def _validate_describe(self, stmt: Dict[str, Any]) -> None:
        pass

    def _validate_test(self, stmt: Dict[str, Any]) -> None:
        pass

    def _validate_regress(self, stmt: Dict[str, Any]) -> None:
        pass

    def _validate_plot(self, stmt: Dict[str, Any]) -> None:
        pass

    def _validate_conclude(self, stmt: Dict[str, Any]) -> None:
        pass

    def _validate_ask_table(self, stmt: Dict[str, Any]) -> None:
        pass

